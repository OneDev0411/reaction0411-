# Cart Schema
"The cart holds selected items until order is placed."
type Cart implements Node {
  "The Cart ID"
  _id: ID!

  # We're currently using User on the Cart.
  # Enforce database uniqueness such that an account only has one cart.
  "The account that owns the cart. Some carts are created for anonymus users. Anonymous carts have a null account."
  account: Account

  "The date and time at which the cart was created, which is when the first item was added to it."
  createdAt: DateTime!

  "The items that have been added to the cart. A cart is not created until the first item is added. Items can be removed from a cart, and a cart is not deleted if all items are removed from it. Because all items may have been removed, this may be an empty array."
  items: [CartItem]!

  "The shop that owns the cart."
  shop: Shop!

  # This value
  "The date and time at which this cart was last updated."
  updatedAt: DateTime!

  # Read-only: Carts that don't have an account should be considered anonymous
  # and should be cleaned up after some time. This should not be set explicitly
  # on the cart but can be derived and add to the Cart as a read-only
  # attribute (read, value from a function.) The cart expiration ttl can then be
  # modified without having to modify cart records.
  # This value should not be stored in the database.
  # Cart expiry is: updated_at + cart_expiry_threshold < now
  "The date and time at which the cart will expire."
  expiresAt: DateTime!
}

"Wraps a list of `CartItem`s, providing pagination cursors and information."
type CartItemConnection implements NodeConnection {
  edges: [CartItemEdge]
  nodes: [CartItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

"A connection edge in which each node is a `CartItem` object"
type CartItemEdge implements NodeEdge {
  cursor: ConnectionCursor!
  node: CartItem
}

"""
A single item in a cart. The item contains information about an intended purchase.
"""
type CartItem implements Node {
  "The cart item ID"
  _id: ID!

  "The date and time at which this item was added to the associated cart. If an item is added, removed, and then added again, this will reflect the most recent addition."
  addedAt: DateTime! # Should this be "createdAt" ?

  "The date and time at which the cart item was created. If an item is added, removed, and then added again, the original item is destroyed and this field will reflect the time it was created for the most recent addition."
  createdAt: DateTime!

  "Arbitrary additional metadata about this cart item."
  metafields: [Metafield]

  "Packing information such as item weight, height, length, and depth."
  parcel: ShippingParcel

  "The current price of the item"
  price: Float!

  "The currency for the `price` and `priceWhenAdded` fields"
  priceCurrency: Currency!

  # This will permit us to perform calculations based on how the price has changed since
  # the item was added to the cart.
  "The price at which this item was listed when it was added to the cart"
  priceWhenAdded: Float!

  "The product and chosen options"
  productConfiguration: ProductConfiguration!

  "The quantity of this item that has been added to the cart. This must be a positive integer. Remove this `CartItem` from it's associated cart if you want `0` of this item."
  quantity: Int!

  # QUESTION: This implies that cart items can be from different shops.
  # Is it possible that certain shops share a cart but other shops are not
  # included in that sharing? How is that defined? Probably not applicable on
  # the cart item but at the cart itself.
  #
  # TODO: shopId is not currently required but it should be made required to
  # avoid issues on cart sharing reconfiguration.
  "The shop associated with this cart item."
  shop: Shop

  # TODO: What is this? Simply denormalization? Can this attribute be fetched
  # directly from the product now in GraphQL?
  # Should this be embedded within the productConfiguration
  "The type of product, used to display cart items differently"
  type: String

  "The date and time at which this item was last updated"
  updatedAt: DateTime!
}

"Product configuration data"
type ProductConfiguration {
  # This is Product ID, but should not be used to couple the cart item or product configuration to the Product
  # We're adding Product to the cart which is why we're not using the CatalogProductId here
  "The Product ID"
  productId: ID!

  "The ProductVariant ID, if there is one"
  productVariantId: ID

  "A title for use in cart/orders that conveys the selected product's title + chosen options"
  title: String!
}

enum CartReconciliationMode {
  merge
  keepAccountCart
  keepAnonymousCart
}

####################
# Queries
####################

extend type Query {
  "Finds a cart by the cart ID and anonymous cart token."
  anonymousCartByCartId(cartId: ID!, token: String!): Cart

  # Access control should ensure that only authenticated users can find their own
  # cart. Additionally, administrative roles can find carts.
  # Shop ID is necessary if shops have separate carts but share the same account pool
  "Find a cart for a given account ID."
  accountCartByAccountId(accountId: ID!, shopId: ID!): Cart
}

####################
# Inputs
####################

input CreateCartInput {
  "Array of items to add to new cart."
  items: [CartItemInput]!  # NOTE: Don't allow creation of an empty cart

  "ShopId association for the cart."
  shopId: ID!              # NOTE: We'll require shopId though it's not in current code.

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

# Input for adding item(s) to a cart.
# Do we need catalog item information? Maybe do this as part of the "analytics" event tracking.
input CartItemInput {
  "Arbitrary additional metadata about this cart item."
  metafields: [MetafieldInput]

  "The product and chosen options"
  productConfiguration: ProductConfigurationInput!

  quantity: Int!

  "ShopId from which the product is added."
  shopId: ID! # NOTE: Should we keep this? Can a product have either multiple ShopIds or no ShopId?

  "The current price of this item"
  price: Float!

  "The currency for the `price` and `priceWhenAdded` fields"
  priceCurrency: String!
}

input ProductConfigurationInput {
  "The Product ID"
  productId: ID!

  "The ProductVariant ID"
  productVariantId: ID!

  "A title for use in cart/orders that conveys the selected product's title + chosen options"
  title: String!
}

input AddCartItemsInput {
  "The cart ID"
  cartId: ID!

  "Array of items to be added to the cart"
  items: [CartItemInput]!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input RemoveCartItemsInput {
  "The cart ID"
  cartId: ID!,

  "Array of items to remove from the cart."
  cartItemIds: [ID]!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input UpdateCartItemInput {
  "The cart item ID"
  cartItemId: ID!

  "New absolute value for specified cart item's quantity. Not an incremental value."
  quantity: Int!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input UpdateCartItemsQuantityInput {
  "The cart ID"
  cartId: ID!

  "Array of cart item quantities to update."
  items: [UpdateCartItemInput]!

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}

input ReconcileCartInput {
  "An anonymous cart ID"
  anonymousCartId: ID!

  "An anonymous cart token"
  anonymousCartToken: String!

  "If both an anonymous cart and a cart for the authenticated account are found, how do we combine them? Default mode is `merge`, where all anonymous items are moved into the account cart along with existing account cart items, and quantities are combined."
  mode: CartReconciliationMode

  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String
}


####################
# Payloads
# These types are used as return values for mutation calls
####################

"The payload returned from the `createCart` mutation call"
type CreateCartPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `addCartItems` mutation call"
type AddCartItemsPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `removeCartItems` mutation call"
type RemoveCartItemsPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `updateCartItems` mutation call"
type UpdateCartItemsPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}


"The payload returned from the `reconcileCart` mutation call"
type ReconcileCartPayload {
  "The modified cart"
  cart: Cart!

  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String
}

####################
# Mutations
####################

extend type Mutation {
  # Enforce that at least one item is provided so we don't create empty carts.
  #
  # IMPORTANT: CartID must be treated as (or more) securely as a session ID. We
  # need to prevent brute-force cart id collisions.
  #
  #   See: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
  #
  #   * ID value must provide at least 64 bits of entropy (if a good PRNG is
  #     used, this value is estimated to be half the length of the session ID).
  #   * If a session ID with an entropy of 64 bits is used, it will take an
  #     attacker at least 292 years to successfully guess a valid session ID,
  #     assuming the attacker can try 10,000 guesses per second with 100,000
  #     valid simultaneous sessions available in the web application [2].
  #
  "Create a new cart."
  createCart(input: CreateCartInput!): CreateCartPayload!

  # TODO: Consider returning the connection for the following mutations to
  # resolve questions of which type should be returned.

  # Add an item to cart.
  # If the item already already exists in the cart, then increment quantity.
  # TODO: Consider returning connection?
  "Add item(s) to a cart."
  addCartItems(input: AddCartItemsInput!): AddCartItemsPayload!

  # Once added to cart, items should be referenced by their cart item ID.
  # Enforce that at least one item is in the list.
  "Remove item(s) from a cart."
  removeCartItems(input: RemoveCartItemsInput!): RemoveCartItemsPayload!

  # If cart item input is set to 0, then remove the item.
  "Update cart item(s) quantity. Use absolute quantity."
  updateCartItemsQuantity(input: UpdateCartItemsQuantityInput!): UpdateCartItemsPayload!

  # Reconcile Cart
  "Reconcile an anonymous cart with Account cart, if it exists."
  reconcileCart(input: ReconcileCartInput!): ReconcileCartPayload!
}
