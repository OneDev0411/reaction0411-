# Cart Schema
"The cart holds selected items until order is placed."
type Cart implements Node {
  _id: ID!

  # We're currently using User on the Cart.
  # Enforce database uniqueness such that an account only has one cart.
  "The account that owns the cart."
  account: Account

  # Unused until checkout implementation.
  #billing: [Payment]! # TODO: What is this?

  "TimeStamp at which the entity was created."
  createdAt: DateTime!

  # We want to change discounts but keeping this for now
  # Unused until checkout implementation.
  # "The total discount amount for the cart"
  #discount: Float

  # Only necessary until making an order. Order should take from here or from account email for user cart
  # Unused until checkout implementation.
  # "The email associated with the cart. For anonymous checkout"
  #email: Email

  "The items that have been added to the cart."
  items: [CartItem]!

  # session: Session! # Remove - Moving to sessionless API.

  # Unused until checkout implementation.
  #shipping: [Shipment]! # TODO: What is this?

  "The shop associated with the cart."
  shop: Shop!

  # TODO: Is this the total tax? Calculated at runtime, or flattened?
  # Unused until checkout implementation.
  # "The total tax associated with the cart."
  #tax: Float

  # Unused until checkout implementation.
  #taxRatesByShop: JSONObject # How is this used?

  # Unused until checkout implementation.
  #taxes: [JSONObject] # TODO: What is this?

  # Undecided if token is necessary.
  #"Secret token for anonymous carts, a token needed for requests"
  #token: String

  "TimeStamp at which the entity was last updated."
  updatedAt: DateTime!

  # Unused until checkout
  #workflow: Workflow # Needs more consideration

  # Read-only: Carts that don't have an account should be considered anonymous
  # and should be cleaned up after some time. This should not be set explicitly
  # on the cart but can be derived and add to the Cart as a read-only
  # attribute (read, value from a function.) The cart expiration ttl can then be
  # modified without having to modify cart records.
  # This value should not be stored in the database.
  "TimeStamp at which the cart will expire."
  expiresAt: DateTime!
}

"Wraps a list of `CartItem`s, providing pagination cursors and information."
type CartItemConnection implements NodeConnection {
  edges: [CartItemEdge]
  nodes: [CartItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

"A connection edge in which each node is a `CartItem` object"
type CartItemEdge implements NodeEdge {
  cursor: ConnectionCursor!
  node: CartItem
}

"""
A single item in a cart. The item contains information about an intended purchase.
"""
type CartItem implements Node {
  "A unique identifier for the type."
  _id: ID!

  "Date first added to cart"
  addedAt: DateTime! # Should this be "createdAt" ?

  "User defined fields that can be used for any purpose."
  metafields: [Metafield]

  "Packing information such as item weight, height, length, and depth."
  parcel: ShippingParcel # Should this be required?

  "The current price of the item"
  price: Float!

  "The currency for the `price` and `priceWhenAdded` fields"
  priceCurrency: Currency!

  # This will permit us to perform calculations based on how the price has changed since
  # the item was added to the cart.
  "The price at which this item was listed when it was added to the cart"
  priceWhenAdded: Float!

  # QUESTION: Does productConfiguration satisfy this TODO?
  # TODO: Variant metadata (from attribute reflection) is needed on the cart item, but should be defined.
  "The product and chosen options"
  productConfiguration: ProductConfiguration!

  "The quantity of items that has been added to the cart."
  quantity: Int!

  # QUESTION: This implies that cart items can be from different shops.
  # Is it possible that certain shops share a cart but other shops are not
  # included in that sharing? How is that defined? Probably not applicable on
  # the cart item but at the cart itself.
  #
  # TODO: shopId is not currently required but it should be made required to
  # avoid issues on cart sharing reconfiguration.
  "The shop associated with this cart item."
  shop: Shop

  # TODO: What is this? Simply denormalization? Can this attribute be fetched
  # directly from the product now in GraphQL?
  # Should this be embedded within the productConfiguration
  "The type of product, used to display cart items differently"
  type: String

  "Date last updated"
  updatedAt: DateTime!

  ###
  # Removed
  ###

  # cartItemId: String # Remove. This is only used in order, not cart.

  # This information moved to ProductConfiguration
  # "The product that was added in this cart item."
  # product: CatalogProductOrVariant! # TODO: This is the incorrect type. Fix it.

  # Moved into ProductConfiguration
  #"The display title of the item in the cart."
  #title: String

  # TODO: What is this? Any way around the blackbox?
  # Unused until checkout implementation.
  # taxData: JSONObject

  # QUESTION: Is this calculated at run-time, this read-only?
  # Unused until checkout implementation.
  #taxRate: Float

  # Unused until checkout implementation.
  #shippingMethod: JSONObject # Any way around the blackbox?

  # What is this? Any way around the blackbox? Does it store info from the
  # payment transaction?  Perhaps it should not be visible to the customer?
  # Require special permissions.
  # TODO: Security/Auth - Customers should not see this!
  #transaction: JSONObject
}

"Product configuration data for a cart item"
type ProductConfiguration {
  # This is Product ID, but should not be used to couple the cart item or product configuration to the Product
  # We're adding Product to the cart which is why we're not using the CatalogProductId here
  "The Product ID"
  productId: ID!

  "The ProductVariant ID, if there is one"
  productVariantId: ID

  ###
  # FUTURE: The list of chosen options for all configurable attributes. This will be set if there is no
  # `catalogProductVariantId` for a configurable product
  ###
  # This is based on if we would move toward my proposal of flattening options to become “configurable attributes”
  # instead, and then support “dynamic variants”. So if I used a configurator to build a specific product configuration
  # that was never pre-created as a specific variant with a sku, then my purchase would be defined not by a
  # `productVariantId` but rather by an array of my chosen options for all configurable attributes.
  #
  # Say I had a simple T-shirt product, with configurable attributes of “size” and “color”, but I can make it any
  # of millions of colors custom for you. The “color” option just has you enter a hex value. As the operator, I will
  # not pre-create several million different variants. Instead, the shopper’s chosen “product configuration” will be
  # defined as `{ productId: "123", productVariantId: null, options: [{ attributeId: "444", value: "small" },
  # { attributeId: "555", value: "#000000" }], title: "Small #000000 T-shirt" }`
  #
  # So each of those attributeId/value combos is a `ProductOptionChoice`.
  "An ordered list of product options/attributes that were selected"
  options: [ProductOption]

  "A title for use in cart/orders that conveys the selected product's title + chosen options"
  title: String!
}

"Chosen product option information"
type ProductOption {
  "Option or attribute label - e.g. color"
  label: String
  "Order of this option in the list of options, ascending."
  position: Int
  "Option or attribute value - e.g. blue"
  value: String

  # Future: we may implement an attribute service and permit configuration
  # of attributes outside of the context of a Product
  # "Attribute ID"
  # attributeId: ID
}

enum CartReconciliationMode {
  merge
  keepAccountCart
  keepAnonymousCart
}

# Queries
extend type Query {
  "Finds a cart by the cart ID."
  anonymousCartByCartId(cartId: ID!): Cart

  # Access control should ensure that only authenticated users can find their own
  # cart. Additionally, administrative roles can find carts.
  # Shop ID is necessary if shops have separate carts but share the same account pool
  "Find a cart for a given account ID."
  accountCartByAccountId(accountId: ID!, shopId: ID!): Cart
}

input CreateCartInput {
  "Array of items to add to new cart."
  items: [CartItemInput]!  # NOTE: Don't allow creation of an empty cart

  "ShopId association for the cart."
  shopId: ID!              # NOTE: We'll require shopId though it's not in current code.
}

# Input for adding item(s) to a cart.
# Do we need catalog item information? Maybe do this as part of the "analytics" event tracking.
input CartItemInput {
  "Date first added to cart"
  addedAt: DateTime! # Should this be createdAt?

  "Abitrary metadata."
  metafields: [MetafieldInput]

  "The product and chosen options"
  productConfiguration: ProductConfigurationInput

  quantity: Int!

  "ShopId from which the product is added."
  shopId: ID! # NOTE: Should we keep this? Can a product have either multiple ShopIds or no ShopId?

  "The current price of this item"
  price: Float!

  # QUESTION: What should properties should be included in the CurrencyInput schema?
  "The currency for the `price` and `priceWhenAdded` fields"
  priceCurrency: CurrencyInput!

  "The price at which this item was listed when it was added to the cart"
  priceWhenAdded: Float!

  "Date last updated"
  updatedAt: DateTime!
}

input ProductConfigurationInput {
  "The Product ID"
  productId: ID!

  "The ProductVariant ID, if there is one"
  productVariantId: ID

  "An ordered list of product options/attributes that were selected"
  options: [ProductOptionInput]

  "A title for use in cart/orders that conveys the selected product's title + chosen options"
  title: String!
}

"Chosen product option information"
input ProductOptionInput {
  "Option or attribute label - e.g. color"
  label: String

  "Option or attribute value - e.g. blue"
  value: String

  "Order of this option in the list of options, ascending."
  position: Int
}


input AddCartItemInput {
  cartId: ID!,
  "Array of items to be added to the cart"
  items: [CartItemInput]!
}

input RemoveCartItemsInput {
  cartId: ID!,
  "Array of items to remove from the cart."
  cartItemIds: [ID]!
}

input UpdateCartItemInput {
  cartItemId: ID!
  "New absolute value for specified cart item's quantity. Not an incremental value."
  quantity: Int!
}

input UpdateCartItemsQuantityInput {
  cartId: ID!
  "Array of cart item quantities to update."
  items: [UpdateCartItemInput]!
}

extend type Mutation {
  # Enforce that at least one item is provided so we don't create empty carts.
  #
  # IMPORTANT: CartID must be treated as (or more) securely as a session ID. We
  # need to prevent brute-force cart id collisions.
  #
  #   See: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
  #
  #   * ID value must provide at least 64 bits of entropy (if a good PRNG is
  #     used, this value is estimated to be half the length of the session ID).
  #   * If a session ID with an entropy of 64 bits is used, it will take an
  #     attacker at least 292 years to successfully guess a valid session ID,
  #     assuming the attacker can try 10,000 guesses per second with 100,000
  #     valid simultaneous sessions available in the web application [2].
  #
  "Create a new cart."
  createCart(input: CreateCartInput!): Cart!

  # TODO: Consider returning the connection for the following mutations to
  # resolve questions of which type should be returned.

  # Add an item to cart.
  # If the item already already exists in the cart, then increment quantity.
  # TODO: Consider returning connection?
  "Add item(s) to a cart."
  addCartItems(input: AddCartItemInput!): Cart! # CartItemConnection

  # Once added to cart, items should be referenced by their cart item ID.
  # Enforce that at least one item is in the list.
  "Remove item(s) from a cart."
  removeCartItems(input: RemoveCartItemsInput!): Cart! # CartItemConnection???

  # If cart item input is set to 0, then remove the item.
  "Update cart item(s) quantity. Use absolute quantity."
  updateCartItemsQuantity(input: UpdateCartItemsQuantityInput!): Cart! # CartItemConnection

  # Reconcile Cart
  "Reconcile an anonymous cart with Account cart, if it exists."
  reconcileCart(anonymousCartId: ID!, mode: CartReconciliationMode): Cart
}
