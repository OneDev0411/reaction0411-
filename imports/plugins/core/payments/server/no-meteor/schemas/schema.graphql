extend type Query {
  """
  Get a list of all payment methods available during a checkout. This may filter by auth,
  active/inactive, IP/region, shop, etc. To get the full list, use the `paymentMethods`
  query with proper authorization.
  """
  availablePaymentMethods(shopId: ID!): [PaymentMethod]!

  "Get a full list of all payment methods"
  paymentMethods(shopId: ID!): [PaymentMethod]!
}

extend type Mutation {
  "Capture one or more payments for an order"
  captureOrderPayments(input: CaptureOrderPaymentsInput!): CaptureOrderPaymentsPayload!

  "Enable a payment method for a shop"
  enablePaymentMethodForShop(input: EnablePaymentMethodForShopInput!): EnablePaymentMethodForShopPayload!
}

"""
Information about a payment made
"""
type Payment implements Node {
  "The Payment ID"
  _id: ID!

  """
  The amount that will be applied to this payment method. If there are multiple payment methods applied to the
  cart, this may be less than the cart total.
  """
  amount: Money!

  """
  If status is "error" due to a capture error, this code describes the error in a machine-readable way.
  """
  captureErrorCode: String

  """
  If status is "error" due to a capture error, this code describes the error in a human-readable way.
  """
  captureErrorMessage: String

  "For card payments, the brand of the card. Useful for showing card icons for common brands."
  cardBrand: String

  "The date and time at which this payment was created"
  createdAt: DateTime!

  """
  The shopper-provided data needed to complete the payment using this method.
  For example, a billing address, store credit code, stored credit card ID, etc.
  """
  data: PaymentData

  "Use this identifier when showing this payment in a user interface"
  displayName: String!

  "Has the payment authorization been canceled?"
  isAuthorizationCanceled: Boolean!

  "Has the payment been captured? If false, it is just an authorization."
  isCaptured: Boolean!

  "The payment method"
  method: PaymentMethod!

  "The current status of this payment"
  status: PaymentStatus!
}

"Valid payment statuses"
enum PaymentStatus {
  adjustments
  approved
  completed
  created
  error
  partialRefund
  refunded
}

# Use `extend union` to define a payment plugin's PaymentData type
"Data identifying a payment for an order"
union PaymentData

# Use `extend enum` to add a plugin's payment method name
"The name of a payment method, which is how payment methods are keyed"
enum PaymentMethodName {
  none
}

# Use `extend union` to define a payment plugin's PaymentMethodData type
union PaymentMethodData

"Describes a payment method"
type PaymentMethod {
  "Data for this method. The data format differs for each method"
  data: PaymentMethodData

  "Human-readable display name"
  displayName: String!

  "Whether the payment method is enabled on a given shop"
  isEnabled: Boolean!

  "The payment method name. Any valid name that has been registered by a payment plugin. e.g., saved_card"
  # TODO: this being a string is temporary until extend works for enums, at which point we'll use PaymentMethodName
  name: String!

  "Name of the plugin that added the payment method"
  pluginName: String!
}

"Input for the `enablePaymentMethodForShop` mutation"
input EnablePaymentMethodForShopInput {
  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String

  "True to enable it or false to disable it"
  isEnabled: Boolean!

  "The name of the payment method to enable or disable"
  paymentMethodName: String!

  "The ID of the shop for which this payment method should be enabled or disabled"
  shopId: ID!
}

type EnablePaymentMethodForShopPayload {
  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String

  "The full list of payment methods for the shop"
  paymentMethods: [PaymentMethod]!
}

"Input for the `captureOrderPayments` mutation"
input CaptureOrderPaymentsInput {
  "An optional string identifying the mutation call, which will be returned in the response payload"
  clientMutationId: String

  "The order ID"
  orderId: ID!

  "The IDs of one or more payments to capture for this order"
  paymentIds: [ID]!

  "The ID of the shop that owns this order"
  shopId: ID!
}

"Response from the `captureOrderPayments` mutation"
type CaptureOrderPaymentsPayload {
  "The same string you sent with the mutation params, for matching mutation calls with their responses"
  clientMutationId: String

  "The updated order"
  order: Order!
}
